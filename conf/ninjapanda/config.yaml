---
# ninjapanda will look for a configuration file named `config.yaml` (or `config.json`) in the following order:
#
# - `/etc/ninjapanda`
# - `~/.ninjapanda`
# - current working directory

# The url clients will connect to.
# Typically this will be a domain like:
#
# https://myninjapanda.example.com:443
#
server_url: http://127.0.0.1:8080

# Address to listen to / bind to on the server
#
listen_addr: 0.0.0.0:8080

# Address to listen to /metrics, you may want
# to keep this endpoint private to your internal
# network
#
metrics_listen_addr: 127.0.0.1:9090

# Address to listen for gRPC.
# gRPC is used for controlling a ninjapanda server
# remotely with the CLI
# Note: Remote access _only_ works if you have
# valid certificates.
grpc_listen_addr: 0.0.0.0:50443

# Allow the gRPC admin interface to run in INSECURE
# mode. This is not recommended as the traffic will
# be unencrypted. Only enable if you know what you
# are doing.
grpc_allow_insecure: true

# Private key used encrypt the traffic between ninjapanda
# and clients.
# The private key file which will be
# autogenerated if it's missing
#private_key_path: /etc/ninjapanda/private.key
private_key_path: "/db/pvt_key"

# The Noise section includes specific configuration for the
# TS2021 Noise procotol
noise:
  # The Noise private key is used to encrypt the
  # traffic between ninjapanda and clients when
  # using the new Noise-based protocol. It must be different
  # from the legacy private key.
  #private_key_path: /etc/ninjapanda/noise_private.key
  private_key_path: "/db/pvt_noise_key"

# List of IP prefixes to allocate tailaddresses from.
# Each prefix consists of either an IPv4 or IPv6 address,
# and the associated prefix length, delimited by a slash.
# While this looks like it can take arbitrary values, it
# needs to be within IP ranges supported by the client.
# IPv6: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#LL81C52-L81C71
# IPv4: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#L33
ip_prefixes:
  - fd7a:115c:a1e0::/48
  - 100.64.0.0/10

# RELAY is a system used when a direct
# connection cannot be established.
# https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-relay
#
# ninjapanda needs a list of RELAY servers that can be presented
# to the clients.
relay:
  server:
    # If enabled, runs the embedded RELAY server and merges it into the rest of the RELAY config
    # The Ninjapanda server_url defined above MUST be using https, RELAY requires TLS to be in place
    enabled: false

    # Region ID to use for the embedded RELAY server.
    # The local RELAY prevails if the region ID collides with other region ID coming from
    # the regular RELAY config.
    region_id: 999

    # Region code and name are displayed in the UI to identify a RELAY region
    region_code: "ninjapanda"
    region_name: "Ninjapanda Embedded RELAY"

    # Listens in UDP at the configured address for STUN connections to help on NAT traversal.
    # When the embedded RELAY server is enabled stun_listen_addr MUST be defined.
    #
    # For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/
    stun_listen_addr: "0.0.0.0:3478"

  # List of externally available RELAY maps encoded in JSON
  urls:
    - https://resources.optm.com/relay-dev.json
  # - https://controlplane.tailscale.com/relaymap/default

  # Locally available RELAY map files encoded in YAML
  #
  # This option is mostly interesting for people hosting
  # their own RELAY servers:
  # https://tailscale.com/kb/1118/custom-relay-servers/
  #
  # paths:
  #   - /etc/ninjapanda/relay-example.yaml
  paths: []

  # If enabled, a worker will be set up to periodically
  # refresh the given sources and update the relaymap
  # will be set up.
  auto_update_enabled: true

  # How often should we check for RELAY updates?
  update_frequency: 24h

# Disables the automatic check for ninjapanda updates on startup
disable_check_updates: false

# Time before an inactive ephemeral node is deleted?
ephemeral_node_inactivity_timeout: 30m

# Period to check for node updates in the tailnet. A value too low will severily affect
# CPU consumption of Ninjapanda. A value too high (over 60s) will cause problems
# to the nodes, as they won't get updates or keep alive messages in time.
# In case of doubts, do not touch the default 10s.
node_update_check_interval: 10s

# SQLite config
#db_type: sqlite3
#db_path: /etc/ninjapanda/db.sqlite

# Postgres config
# docker.for.mac.host.internal
db_type: postgres
db_host: localhost
db_port: 5432
db_name: ninjapanda
db_user: ninjaadmin
db_pass: n1nj@@dm1n

# If other 'sslmode' is required instead of 'require(true)' and 'disabled(false)', set the 'sslmode' you need
# in the 'db_ssl' field. Refers to https://www.postgresql.org/docs/current/libpq-ssl.html Table 34.1.
db_ssl: false

### TLS configuration
#
## Let's encrypt / ACME
#
# ninjapanda supports automatically requesting and setting up
# TLS for a domain with Let's Encrypt.
#
# URL to ACME directory
acme_url: https://acme-v02.api.letsencrypt.org/directory

# Email to register with ACME provider
acme_email: ""

# Domain name to request a TLS certificate for:
tls_letsencrypt_hostname: ""

# Path to store certificates and metadata needed by
# letsencrypt
tls_letsencrypt_cache_dir: /var/lib/ninjapanda/cache

# Type of ACME challenge to use, currently supported types:
# HTTP-01 or TLS-ALPN-01
# See [docs/tls.md](docs/tls.md) for more information
tls_letsencrypt_challenge_type: HTTP-01
# When HTTP-01 challenge is chosen, letsencrypt must set up a
# verification endpoint, and it will be listening on:
# :http = port 80
tls_letsencrypt_listen: ":http"

## Use already defined certificates:
tls_cert_path: ""
tls_key_path: ""

log:
  # Output formatting for logs: text or json
  format: text
  level: trace

# Path to a file containg ACL policies.
# ACLs can be defined as YAML or HUJSON.
# https://tailscale.com/kb/1018/acls/
acl_policy_path: ""

## DNS
#
# ninjapanda supports DNS configuration and MagicDNS.
# Please have a look to their KB to better understand the concepts:
#
# - https://tailscale.com/kb/1054/dns/
# - https://tailscale.com/kb/1081/magicdns/
# - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/
#
dns_config:
  # Whether to prefer using Ninjapanda provided DNS or use local.
  override_local_dns: true

  # List of DNS servers to expose to clients.
  nameservers:
    - 1.1.1.1

  # NextDNS (see https://tailscale.com/kb/1218/nextdns/).
  # "abc123" is example NextDNS ID, replace with yours.
  #
  # With metadata sharing:
  # nameservers:
  #   - https://dns.nextdns.io/abc123
  #
  # Without metadata sharing:
  # nameservers:
  #   - 2a07:a8c0::ab:c123
  #   - 2a07:a8c1::ab:c123

  # Split DNS (see https://tailscale.com/kb/1054/dns/),
  # list of search domains and the DNS to query for each one.
  #
  # restricted_nameservers:
  #   foo.bar.com:
  #     - 1.1.1.1
  #   darp.ninjapanda.net:
  #     - 1.1.1.1
  #     - 8.8.8.8

  # Search domains to inject.
  domains: []

  # Extra DNS records
  # so far only A-records are supported (on the tailscale side)
  # See https://github.com/juanfont/headscale/blob/main/docs/dns-records.md#Limitations
  # extra_records:
  #   - name: "grafana.myvpn.example.com"
  #     type: "A"
  #     value: "100.64.0.3"
  #
  #   # you can also put it in one line
  #   - { name: "prometheus.myvpn.example.com", type: "A", value: "100.64.0.3" }

  # Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).
  # Only works if there is at least a nameserver defined.
  magic_dns: true

  # Defines the base domain to create the hostnames for MagicDNS.
  # `base_domain` must be a FQDNs, without the trailing dot.
  # The FQDN of the hosts will be
  # `hostname.namespace.base_domain` (e.g., _myhost.mynamespace.example.com_).
  base_domain: ztmesh.net

# Unix socket used for the CLI to connect without authentication
# Note: for local development, you probably want to change this to:
# unix_socket: ./ninjapanda.sock
unix_socket: /var/run/ninjapanda.sock
unix_socket_permission: "0770"

#
# ninjapanda supports experimental OpenID connect support,
# it is still being tested and might have some bugs, please
# help us test it.
# OpenID Connect
# oidc:
#   only_start_if_oidc_is_available: true
#   issuer: "https://your-oidc.issuer.com/path"
#   client_id: "your-oidc-client-id"
#   client_secret: "your-oidc-client-secret"
#   # Alternatively, set `client_secret_path` to read the secret from the file.
#   # It resolves environment variables, making integration to systemd's
#   # `LoadCredential` straightforward:
#   client_secret_path: "${CREDENTIALS_DIRECTORY}/oidc_client_secret"
#   # client_secret and client_secret_path are mutually exclusive.
#
#   Customize the scopes used in the OIDC flow, defaults to "openid", "profile" and "email" and add custom query
#   parameters to the Authorize Endpoint request. Scopes default to "openid", "profile" and "email".
#
#   scope: ["openid", "profile", "email", "custom"]
#   extra_params:
#     domain_hint: example.com
#
#   List allowed principal domains and/or users. If an authenticated user's domain is not in this list, the
#   authentication request will be rejected.
#
#   allowed_domains:
#     - example.com
# Groups from keycloak have a leading '/'
#   allowed_groups:
#     - /ninjapanda
#   allowed_users:
#     - alice@example.com
#
#   If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.
#   This will transform `first-name.last-name@example.com` to the namespace `first-name.last-name`
#   If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following
#   namespace: `first-name.last-name.example.com`
#
#   strip_email_domain: true

# Logtail configuration
# Logtail is logging and auditing infrastructure, it allows the control panel
# to instruct tailscale nodes to log their activity to a remote server.
logtail:
  # Enable logtail for this ninjapandas clients.
  # As there is currently no support for overriding the log server in ninjapanda, this is
  # disabled by default. Enabling this will make your clients send logs to Optm Inc.
  enabled: false

# Enabling this option makes devices prefer a random port for WireGuard traffic over the
# default static port 41641. This option is intended as a workaround for some buggy
# firewall devices. See https://tailscale.com/kb/1181/firewalls/ for more information.
randomize_client_port: false

machine_auth_url: http://localhost:3007/login?next_url=client
